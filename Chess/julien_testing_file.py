#Changes to mouse handler

if len(player_clicks) == 2:     #after the second click
    #now we make our move!

    move = chess_machine.Move(player_clicks[0], player_clicks[1], game_state.board)
    print(move.get_chess_notation())

    for i in range(len(valid_moves)):
        if move == valid_moves[i]:
            game_state.make_move(valid_moves[i])        #move generated by the engine, not the move generated by the player
            move_made = True
            square_selected = ()    #reset user clicks
            player_clicks = []      #resets user clicks
    if not move_made:
        player_clicks = [square_selected]



# en-passant method drafts





'''
PAWN PROMOTION
'''
#Changes to Move class (In constructor)

self.is_pawn_promotion = False      #presumed false
if (self.piece_moved == 'wP' and self.end_row == 0) or (self.piece_moved == 'bP' and self.end_row == 7):
    self.is_pawn_promotion = True        #make it true if pawn reaches end row


#CHANGES TO MAKE MOVE METHOD
if move.is_pawn_promotion:
    self.board[move.end_row][move.end_col] = move.pieced_moved[0] + 'Q' #makes the piece moved to a promotion square actually a queen. move.piece_moved[0] grabs the color.
    





#Note: To add promotion to other pieces, have to change main function in chess display, right after game_state.make_move.
#Otherwise bug in code when computer generates all moves to see whcih are valid -- it'll stop to ask for user input even if
#the move wasn't made

#for now lets just make it only queen